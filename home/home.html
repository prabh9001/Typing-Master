<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Progressive Typing Tutor</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --text-color: #333;
            --accent-color: #007bff;
            --success-color: #28a745;
            --error-color: #dc3545;
            --box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            background: url(https://images.unsplash.com/photo-1526779259212-939e64788e3c?fm=jpg&q=60&w=3000&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxzZWFyY2h8M3x8ZnJlZSUyMGltYWdlc3xlbnwwfHwwfHx8MA%3D%3D);
        }

        h1 { margin-bottom: 10px;
            color: var(--accent-color);
            color: #030303;
        }

        #app-container {
            background: rgb(255, 193, 60);
            padding: 30px;
            border-radius: 12px;
            box-shadow: var(--box-shadow);
            width: 100%;
            max-width: 800px;
            text-align: center;
        }

        /* Controls Area */
        #controls {
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #ffb8b8;
            font-size: 16px;
        }

        #stats { font-weight: bold; color: #666; }

        /* Typing Display Area */
        #typing-display {
            font-family: 'Courier New', Courier, monospace; /* Monospace is crucial for typing tutors */
            font-size: 32px;
            line-height: 1.5;
            background-color: #fafafa;
            padding: 25px;
            border-radius: 8px;
            border: 2px solid #eee;
            white-space: pre-wrap; /* Preserve spaces and breaks */
            text-align: left;
            min-height: 150px;
            user-select: none; /* Prevent highlighting text while typing */
            position: relative;
        }

        /* Overlay for focus message */
        #focus-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: var(--accent-color);
            border-radius: 8px;
            cursor: pointer;
        }

        /* Character styling states */
        .char { color: #000000; } /* Future characters */
        .char.correct { color: var(--success-color); }
        .char.incorrect { color: var(--error-color); background-color: #f8d7da; }
        
        .char.current {
            color: var(--text-color);
            background-color: #e7f1ff;
            border-bottom: 3px solid var(--accent-color);
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            50% { border-bottom-color: transparent; }
        }

        #message-area {
            margin-top: 20px;
            font-weight: bold;
            min-height: 1.2em;
            color: var(--accent-color);
        }
    </style>
</head>
<body>

    <h1>Fast Progressive Typing</h1>

    <div id="app-container">
        <div id="controls">
            <select id="lesson-select">
                </select>
            <div id="stats">WPM: 0 | Accuracy: 100%</div>
        </div>

        <div id="typing-display">
            <div id="focus-overlay">Click here to start typing</div>
        </div>

        <div id="message-area"></div>
    </div>


<script>
    /**
     * CONFIGURATION & DATA
     * A small dictionary of common words to generate practice text.
     */
    const wordBank = [
        "the", "be", "to", "of", "and", "a", "in", "that", "have", "it", "for", "not", "on", "with", "he", "as", "you", "do", "at", "this", "but", "his", "by", "from", "they", "we", "say", "her", "she", "or", "an", "will", "my", "one", "all", "would", "there", "their", "what", "so", "up", "out", "if", "about", "who", "get", "which", "go", "me", "when", "make", "can", "like", "time", "no", "just", "him", "know", "take", "people", "into", "year", "your", "good", "some", "could", "them", "see", "other", "than", "then", "now", "look", "only", "come", "its", "over", "think", "also", "back", "after", "use", "two", "how", "our", "work", "first", "well", "way", "even", "new", "want", "because", "any", "these", "give", "day", "most", "us", "is", "are", "was", "were", "had", "has", "dad", "sad", "fad", "lad", "lass", "fall", "gall", "shall", "ask", "flask", "task", "desk", "led", "fed", "red", "see", "fee", "bee", "gee", "lee", "sea", "tea", "pea", "eat", "ate", "rat", "hat", "sat", "fat", "mat", "pat", "bat", "cat", "vat", "zap", "yap", "rap", "tap", "gap", "lap", "nap", "map", "cap", "had", "lad", "sad", "dad", "did", "lid", "hid", "kid", "rid", "sid", "wit", "sit", "hit", "fit", "bit", "kit", "lit", "pit", "pot", "lot", "cot", "dot", "got", "hot", "jot", "not", "rot", "tot", "top", "pop", "hop", "mop", "lop", "fop", "sop", "cow", "how", "bow", "row", "sow", "tow", "vow", "wow", "box", "fox", "pox", "lox", "sox", "boy", "coy", "toy", "joy", "soy", "fry", "try", "pry", "cry", "dry", "wry", "sky", "why", "shy", "thy", "my", "by", "fly", "ply", "sly", "spy", "sty", "aye", "eye", "dye", "lie", "pie", "tie", "vie", "die", "cue", "due", "hue", "rue", "sue", "blue", "clue", "glue", "true", "few", "hew", "mew", "new", "pew", "yew", "add", "all", "ask", "ate", "bad", "bag", "bed", "bee", "beg", "bet", "big", "bit", "bog", "box", "boy", "bug", "bun", "bus", "but", "buy", "can", "cap", "car", "cat", "cow", "cry", "cup", "cut", "dad", "day", "did", "dig", "dog", "dot", "dry", "due", "eat", "egg", "end", "eye", "fan", "far", "fat", "few", "fit", "fix", "fly", "fog", "for", "fox", "fry", "fun", "fur", "gap", "gas", "get", "got", "gum", "gun", "guy", "had", "has", "hat", "her", "hid", "him", "his", "hit", "hot", "how", "hug", "hut", "ice", "ill", "ink", "its", "jam", "jar", "jaw", "jay", "jet", "job", "jog", "joy", "jug", "key", "kid", "kit", "lab", "lap", "law", "lay", "led", "leg", "let", "lid", "lie", "lip", "lit", "log", "lot", "low", "mad", "man", "map", "mat", "may", "men", "met", "mix", "mom", "mop", "mud", "mug", "nap", "net", "new", "nod", "not", "now", "nut", "oar", "odd", "off", "old", "one", "our", "out", "owl", "own", "pan", "pat", "paw", "pay", "pea", "peg", "pen", "pet", "pie", "pig", "pin", "pit", "pod", "pop", "pot", "pry", "pup", "put", "rag", "ram", "ran", "rap", "rat", "raw", "ray", "red", "rib", "rid", "rig", "rim", "rip", "rob", "rod", "rot", "row", "rub", "rug", "run", "rut", "sad", "sag", "sat", "saw", "say", "sea", "see", "set", "sew", "she", "shy", "sin", "sip", "sir", "sit", "six", "ski", "sky", "sly", "sob", "son", "soy", "spy", "sun", "tab", "tag", "tan", "tap", "tax", "tea", "ten", "the", "thy", "tie", "tin", "tip", "toe", "top", "toy", "try", "tub", "tug", "two", "use", "van", "vat", "vet", "via", "vie", "wag", "war", "was", "way", "web", "wed", "wee", "wet", "who", "why", "wig", "win", "wit", "won", "wow", "wry", "yes", "yet", "you", "zip", "zoo"
    ];

    /**
     * Lesson definitions.
     * 'keys' defines the NEW keys introduced.
     * The system automatically includes previous lesson keys.
     */
    const lessonDefinitions = [
        { name: "1. Home Row Basics (F, J)", keys: "fj" },
        { name: "2. Home Row Add (D, K)", keys: "dk" },
        { name: "3. Home Row Add (S, L)", keys: "sl" },
        { name: "4. Home Row Add (A, ;)", keys: "a;" },
        { name: "5. Vowels E & I", keys: "ei" },
        { name: "6. R & U", keys: "ru" },
        { name: "7. T & Y", keys: "ty" },
        { name: "8. G & H", keys: "gh" },
        { name: "9. Bottom Row (V, M)", keys: "vm" },
        { name: "10. Bottom Row (C, ,)", keys: "c," },
        { name: "11. Bottom Row (X, .)", keys: "x." },
        { name: "12. Bottom Row (Z, /)", keys: "z/" },
        { name: "13. Top Row (Q, P)", keys: "qp" },
        { name: "14. Top Row (W, O)", keys: "wo" },
        { name: "15. Top Row (B, N)", keys: "bn" },
        // Add numbers/symbols here if desired
    ];

    /**
     * STATE VARIABLES
     */
    let cumulativeKeysStr = ""; // String containing all allowed keys for current lesson
    let targetText = "";        // The actual text string being typed
    let currentIndex = 0;       // Position of cursor in targetText
    let mistakes = 0;
    let startTime = null;
    let isTypingActive = false;

    // DOM Elements
    const lessonSelect = document.getElementById('lesson-select');
    const typingDisplay = document.getElementById('typing-display');
    const statsDisplay = document.getElementById('stats');
    const messageArea = document.getElementById('message-area');
    const focusOverlay = document.getElementById('focus-overlay');

    /**
     * INITIALIZATION & SETUP
     */
    function init() {
        // Populate lesson dropdown
        lessonDefinitions.forEach((lesson, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = lesson.name;
            lessonSelect.appendChild(option);
        });

        // Event Listeners
        lessonSelect.addEventListener('change', loadLesson);
        document.addEventListener('keydown', handleKeypress);
        focusOverlay.addEventListener('click', startTypingSession);
        typingDisplay.addEventListener('click', startTypingSession);

        // Load the first lesson onto the screen
        loadLesson();
    }


    /**
     * CORE LOGIC Functions
     */

    // Called when the user selects a new lesson from dropdown
    function loadLesson() {
        isTypingActive = false;
        focusOverlay.style.display = 'flex'; // Show "click to start"
        messageArea.textContent = "";

        const lessonIndex = parseInt(lessonSelect.value);
        
        // 1. Determine cumulative allowed keys up to this lesson
        cumulativeKeysStr = "";
        for (let i = 0; i <= lessonIndex; i++) {
            cumulativeKeysStr += lessonDefinitions[i].keys;
        }
        // Always allow spacebar
        cumulativeKeysStr += " ";

        // 2. Generate the practice text based on allowed keys
        targetText = generatePracticeText(cumulativeKeysStr);
        
        // 3. Reset state
        currentIndex = 0;
        mistakes = 0;
        startTime = null;
        updateStats();

        // 4. Render the HTML span tags for the text
        renderTextToDisplay();
    }

    // Generates a paragraph of text containing only the allowed keys
    function generatePracticeText(allowedKeys) {
        const allowedSet = new Set(allowedKeys.split(''));
        
        // Filter the wordBank to find words that fit the criteria
        const validWords = wordBank.filter(word => {
            // Check every character in the word
            for (const char of word) {
                if (!allowedSet.has(char)) return false;
            }
            return true;
        });

        // If no words match (rare, usually early lessons), fall back to repeating keys
        if (validWords.length === 0 || validWords.length < 5) {
             // Fallback pattern for very first lessons (e.g., "fff jjj fjf")
             const keysOnly = allowedKeys.replace(" ", "");
             let pattern = "";
             for(let k of keysOnly) { pattern += k.repeat(3) + " "; }
             for(let i=0; i<5; i++) {
                 pattern += keysOnly.split('').sort(() => 0.5 - Math.random()).join('') + " ";
             }
             return pattern.trim();
        }

        // Shuffle valid words and pick roughly 30 to form a paragraph
        const shuffled = validWords.sort(() => 0.5 - Math.random());
        // Cap at 35 words or total length available
        const selectedWords = shuffled.slice(0, Math.min(35, shuffled.length));
        return selectedWords.join(' ');
    }


    // Renders targetText into individual <span> elements
    function renderTextToDisplay() {
        typingDisplay.innerHTML = ''; // Clear previous
        
        for (let i = 0; i < targetText.length; i++) {
            const span = document.createElement('span');
            span.textContent = targetText[i];
            span.classList.add('char');
            
            if (i === currentIndex) {
                span.classList.add('current');
            }
            typingDisplay.appendChild(span);
        }
        // Re-add overlay if needed
        if(!isTypingActive) typingDisplay.appendChild(focusOverlay);
    }

    function startTypingSession() {
        isTypingActive = true;
        focusOverlay.style.display = 'none';
        // Reset start time on first keypress instead of click
        startTime = null; 
        // Ensure the display has focus so key presses register (though we use document listener)
        typingDisplay.focus();
    }


    /**
     * TYPING EVENT HANDLER
     */
    function handleKeypress(e) {
        if (!isTypingActive) return;
        if (e.key === 'Shift' || e.key === 'CapsLock' || e.key === 'Control' || e.key === 'Alt') return;

        // Start timer on very first actual keypress
        if (startTime === null) {
            startTime = new Date();
        }

        const currentCharSpan = typingDisplay.children[currentIndex];
        const expectedChar = targetText[currentIndex];
        const typedChar = e.key;

        // Simple implementation: No backspace support for speed/simplicity
        // If we wanted backspace: check if e.key === 'Backspace', decrement index, reset classes.

        if (typedChar === expectedChar) {
            // Correct
            currentCharSpan.classList.remove('current', 'incorrect');
            currentCharSpan.classList.add('correct');
            advanceCursor();
        } else {
            // Incorrect
            mistakes++;
            currentCharSpan.classList.remove('current');
            currentCharSpan.classList.add('incorrect');
            // In this simple model, we don't force correction. We move on.
            // To mimic EdClub strictly, we'd stay on the current index until correct.
            // Let's implement the "must type correct to proceed" model:
            // If incorrect, do nothing else. The user must retry the key.
             if(expectedChar === ' ' && typedChar !== ' ') {
                 // Special visual handling for missing a space if desired
             }
        }
        updateStats();
    }

    function advanceCursor() {
        currentIndex++;
        
        // Check if finished
        if (currentIndex >= targetText.length) {
            finishLesson();
            return;
        }
        // Highlight next character
        typingDisplay.children[currentIndex].classList.add('current');
    }

    function updateStats() {
        let wpm = 0;
        let accuracy = 100;

        if (startTime && currentIndex > 0) {
            const currentTime = new Date();
            const timeInMinutes = (currentTime - startTime) / 60000;
            // Standard WPM calculation: (characters / 5) / minutes
            wpm = Math.round(((currentIndex + 1) / 5) / timeInMinutes);
            // Cap WPM at unreasonable numbers for very short bursts
            if(timeInMinutes < 0.05) wpm = 0; 
        }

        const totalTyped = currentIndex + mistakes;
        if (totalTyped > 0) {
            accuracy = Math.round(((totalTyped - mistakes) / totalTyped) * 100);
        }

        statsDisplay.textContent = `WPM: ${wpm || 0} | Accuracy: ${accuracy}% | Mistakes: ${mistakes}`;
    }

    function finishLesson() {
        isTypingActive = false;
        updateStats();
        messageArea.textContent = "Lesson Complete! Loading next...";
        
        // Automatically load next lesson after a short delay
        setTimeout(() => {
            const nextIndex = parseInt(lessonSelect.value) + 1;
            if (nextIndex < lessonDefinitions.length) {
                lessonSelect.value = nextIndex;
                loadLesson();
            } else {
                messageArea.textContent = "Congratulations! You have finished all available lessons.";
                focusOverlay.textContent = "All Done! Refresh to restart.";
                focusOverlay.style.display = 'flex';
            }
        }, 2000);
    }

    // Start the app
    init();

</script>
</body>
</html>